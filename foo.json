{
  "content": "# SPDX-License-Identifier: LGPL-3.0-or-later\n# Copyright (C) 2025-2026 Kris Kirby, KE4AHR\n\n\"\"\"\npyax25_22.core.statemachine.py\n\nAX.25 v2.2 Layer 2 state machine implementation.\n\nImplements all states and transitions per AX.25 v2.2 SDL diagrams.\n\nStates:\n- DISCONNECTED\n- AWAITING_CONNECTION\n- AWAITING_RELEASE\n- CONNECTED\n- TIMER_RECOVERY\n- AWAITING_XID\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nimport logging\n\nfrom .config import AX25Config, DEFAULT_CONFIG_MOD8\nfrom .exceptions import ConnectionStateError\n\nlogger = logging.getLogger(__name__)\n\n\nclass AX25State(Enum):\n    DISCONNECTED = \"disconnected\"\n    AWAITING_CONNECTION = \"awaiting_connection\"\n    AWAITING_RELEASE = \"awaiting_release\"\n    CONNECTED = \"connected\"\n    TIMER_RECOVERY = \"timer_recovery\"\n    AWAITING_XID = \"awaiting_xid\"\n\n\nclass AX25StateMachine:\n    \"\"\"AX.25 Layer 2 state machine.\"\"\"\n\n    def __init__(self, config: AX25Config = DEFAULT_CONFIG_MOD8, layer3_initiated: bool = True):\n        self.config = config\n        self.layer3_initiated = layer3_initiated\n        self.state = AX25State.DISCONNECTED\n        self._modulo = config.modulo\n        self.modulo_mask = 0x07 if self._modulo == 8 else 0x7F\n        self.v_s = self.v_r = self.v_a = 0\n        self.peer_busy = False\n        self.reject_sent = False\n        self.srej_sent = False\n\n    @property\n    def modulo(self) -> int:\n        return self._modulo\n\n    @modulo.setter\n    def modulo(self, value: int) -> None:\n        if value not in (8, 128):\n            raise ValueError(\"Modulo must be 8 or 128\")\n        self._modulo = value\n        self.modulo_mask = 0x07 if value == 8 else 0x7F\n\n    def increment_vs(self) -> None:\n        \"\"\"Increment V(S) with modulo wrap.\"\"\"\n        self.v_s = (self.v_s + 1) & self.modulo_mask\n\n    def transition(self, event: str, frame_type: Optional[str] = None) -> None:\n        \"\"\"Perform state transition based on event.\n\n        Validates transitions per AX.25 v2.2 SDL diagrams.\n        \"\"\"\n        old_state = self.state\n        logger.debug(f\"Transition attempt: {old_state.value} --[{event}]--> ?\")\n\n        # Map legacy supervisory events for backward compatibility\n        if event.endswith(\"_received\") and event[:-9] in {\"RR\", \"RNR\", \"REJ\", \"SREJ\"}:\n            frame_type = event[:-9]\n            event = \"supervisory_received\"\n\n        # DISCONNECTED state transitions\n        if self.state == AX25State.DISCONNECTED:\n            if event == \"connect_request\":\n                if not self.layer3_initiated:\n                    raise ConnectionStateError(\"Connect request not allowed without layer3 initiation\")\n                self.state = AX25State.AWAITING_CONNECTION\n                self.v_s = self.v_r = self.v_a = 0\n                self.peer_busy = self.reject_sent = self.srej_sent = False\n            elif event in (\"SABM_received\", \"SABME_received\"):\n                self.state = AX25State.CONNECTED\n                self.v_s = self.v_r = self.v_a = 0\n                self.peer_busy = self.reject_sent = self.srej_sent = False\n            elif event == \"DISC_received\":\n                # Send DM response, remain disconnected\n                pass\n            else:\n                raise ConnectionStateError(f\"Invalid event '{event}' in DISCONNECTED\")\n\n        # AWAITING_CONNECTION transitions\n        elif self.state == AX25State.AWAITING_CONNECTION:\n            if event in (\"UA_received\", \"DM_received\", \"FRMR_received\"):\n                self.state = AX25State.DISCONNECTED\n            elif event == \"T1_timeout\":\n                self.state = AX25State.DISCONNECTED\n            else:\n                raise ConnectionStateError(f\"Invalid event '{event}' in AWAITING_CONNECTION\")\n\n        # CONNECTED transitions\n        elif self.state == AX25State.CONNECTED:\n            if event == \"disconnect_request\":\n                self.state = AX25State.AWAITING_RELEASE\n            elif event == \"DISC_received\":\n                self.state = AX25State.DISCONNECTED\n            elif event == \"T3_timeout\":\n                # Probe channel state\n                pass\n            elif event == \"T1_timeout\":\n                self.state = AX25State.TIMER_RECOVERY\n            elif event == \"supervisory_received\":\n                if frame_type == \"RNR\":\n                    self.peer_busy = True\n                elif frame_type == \"RR\":\n                    self.peer_busy = False\n                elif frame_type == \"REJ\":\n                    self.reject_sent = True\n                elif frame_type == \"SREJ\":\n                    self.srej_sent = True\n            else:\n                raise ConnectionStateError(f\"Invalid event '{event}' in CONNECTED\")\n\n        # TIMER_RECOVERY transitions\n        elif self.state == AX25State.TIMER_RECOVERY:\n            if event == \"ack_received\":\n                self.state = AX25State.CONNECTED\n            elif event == \"T1_timeout\":\n                self.state = AX25State.CONNECTED\n            else:\n                raise ConnectionStateError(f\"Invalid event '{event}' in TIMER_RECOVERY\")\n\n        # AWAITING_RELEASE transitions\n        elif self.state == AX25State.AWAITING_RELEASE:\n            if event == \"UA_received\":\n                self.state = AX25State.DISCONNECTED\n            elif event == \"T1_timeout\":\n                self.state = AX25State.DISCONNECTED\n            else:\n                raise ConnectionStateError(f\"Invalid event '{event}' in AWAITING_RELEASE\")\n\n        # AWAITING_XID transitions\n        elif self.state == AX25State.AWAITING_XID:\n            if event == \"XID_received\":\n                self.state = AX25State.CONNECTED\n            elif event == \"T1_timeout\":\n                self.state = AX25State.DISCONNECTED\n            else:\n                raise ConnectionStateError(f\"Invalid event '{event}' in AWAITING_XID\")\n\n        else:\n            raise ConnectionStateError(f\"Unknown state {self.state}\")\n\n        logger.debug(f\"Transition: {old_state.value} -> {self.state.value}\")"
}
