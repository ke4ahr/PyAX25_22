{
  "content": "# SPDX-License-Identifier: LGPL-3.0-or-later\n# Copyright (C) 2025-2026 Kris Kirby, KE4AHR\n\n\"\"\"\npyax25_22.core.framing.py\n\nComplete AX.25 v2.2 frame encoding and decoding implementation.\n\nImplements:\n- Full address field with source, destination, and up to 8 digipeaters (H-bit support)\n- All control field formats: I, S, U frames (modulo 8 and 128)\n- PID field handling\n- Information field\n- Bit stuffing / destuffing\n- FCS calculation and verification (CRC-16/CCITT-FALSE)\n\nFully compliant with AX.25 v2.2 specification (July 1998).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport struct\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional, Tuple\nimport logging\n\nfrom .config import AX25Config, DEFAULT_CONFIG_MOD8\nfrom .exceptions import (\n    InvalidAddressError,\n    FCSError,\n    FrameError,\n)\n\nlogger = logging.getLogger(__name__)\n\n# AX.25 constants\nFLAG = 0x7E\nFCS_INIT = 0xFFFF\nFCS_POLY = 0x8408\n\n\ndef fcs_calc(data: bytes) -> int:\n    \"\"\"\n    Calculate AX.25 FCS (CRC-16/CCITT-FALSE).\n\n    Args:\n        data: Bytes over which to compute FCS (address + control + PID + info)\n\n    Returns:\n        16-bit FCS value\n    \"\"\"\n    fcs = FCS_INIT\n    for byte in data:\n        fcs ^= byte\n        for _ in range(8):\n            if fcs & 1:\n                fcs = (fcs >> 1) ^ FCS_POLY\n            else:\n                fcs >>= 1\n    return ~fcs & 0xFFFF  # Final invert\n\n\ndef verify_fcs(data: bytes, received_fcs: int) -> bool:\n    \"\"\"\n    Verify received FCS against calculated value.\n\n    Args:\n        data: Frame data excluding FCS\n        received_fcs: FCS from received frame\n\n    Returns:\n        True if valid\n    \"\"\"\n    calculated = fcs_calc(data)\n    return calculated == received_fcs\n\n\n@dataclass\nclass AX25Address:\n    \"\"\"\n    AX.25 address field with callsign, SSID, and control bits.\n    \"\"\"\n\n    callsign: str\n    ssid: int = 0\n    c_bit: bool = False          # Command/Response bit (bit 6)\n    h_bit: bool = False          # Has been repeated (bit 5)\n\n    def __post_init__(self) -> None:\n        \"\"\"Validate and normalize address.\"\"\"\n        if not (0 <= self.ssid <= 15):\n            raise InvalidAddressError(f\"SSID {self.ssid} out of range (0-15)\")\n\n        callsign_clean = self.callsign.upper().strip().replace(\"-\", \"\")\n        if not (1 <= len(callsign_clean) <= 6):\n            raise InvalidAddressError(f\"Callsign '{self.callsign}' length invalid\")\n\n        # Shift callsign characters left by 1\n        self._call_bytes = bytes((ord(c) << 1) for c in callsign_clean.ljust(6, \" \"))\n\n    def encode(self, last: bool = False) -> bytes:\n        \"\"\"\n        Encode 7-byte address field.\n\n        SSID byte format (per AX.25 v2.2):\n        - Bit 7: Reserved (always 1)\n        - Bit 6: C bit (command/response)\n        - Bit 5: H bit (has been repeated)\n        - Bits 4-1: SSID\n        - Bit 0: Extension (1 = last address)\n        \"\"\"\n        ssid_byte = 0x60  # Bit 7 = 1, bit 6 = 0 initially\n        ssid_byte |= (self.ssid << 1) & 0x1E  # SSID in bits 4-1\n        ssid_byte |= 0x40 if self.c_bit else 0x00  # C bit in bit 6\n        ssid_byte |= 0x20 if self.h_bit else 0x00  # H bit in bit 5\n        ssid_byte |= 0x01 if last else 0x00        # Extension bit\n\n        return self._call_bytes + bytes([ssid_byte])\n\n    @classmethod\n    def decode(cls, data: bytes) -> Tuple[\"AX25Address\", bool]:\n        \"\"\"\n        Decode address field from 7 bytes.\n\n        Returns:\n            (address object, is_last_address)\n        \"\"\"\n        if len(data) < 7:\n            raise InvalidAddressError(\"Address field too short\")\n\n        call_bytes = data[:6]\n        ssid_byte = data[6]\n\n        callsign_chars = []\n        for b in call_bytes:\n            char_code = b >> 1\n            if char_code == 0x20:  # Space padding\n                break\n            callsign_chars.append(chr(char_code))\n        callsign = \"\".join(callsign_chars)\n\n        addr = cls(\n            callsign=callsign,\n            ssid=(ssid_byte >> 1) & 0x0F,\n            c_bit=bool(ssid_byte & 0x40),\n            h_bit=bool(ssid_byte & 0x20),\n        )\n\n        is_last = bool(ssid_byte & 0x01)\n        return addr, is_last\n\n\n@dataclass\nclass AX25Frame:\n    \"\"\"\n    Complete AX.25 frame with full v2.2 support.\n    \"\"\"\n\n    destination: AX25Address\n    source: AX25Address\n    digipeaters: List[AX25Address] = field(default_factory=list)\n    control: int = 0\n    pid: Optional[int] = None\n    info: bytes = b\"\"\n    config: AX25Config = DEFAULT_CONFIG_MOD8\n\n    def encode(self) -> bytes:\n        \"\"\"\n        Encode complete frame with flags, bit stuffing, and FCS.\n        \"\"\"\n        # Address field\n        addr_field = self.destination.encode(last=not self.digipeaters)\n        addr_field += self.source.encode(last=not self.digipeaters)\n\n        for i, digi in enumerate(self.digipeaters):\n            last = i == len(self.digipeaters) - 1\n            addr_field += digi.encode(last=last)\n\n        # Control + PID + Info\n        payload = bytes([self.control & 0xFF])\n        if self.config.modulo == 128 and (self.control & 0x01 == 0):  # Extended I-frame\n            payload += bytes([(self.control >> 8) & 0xFF])\n        if self.pid is not None:\n            payload += bytes([self.pid])\n        payload += self.info\n\n        # FCS over address + payload\n        fcs = fcs_calc(addr_field + payload)\n        frame_body = addr_field + payload + struct.pack(\"<H\", fcs)\n\n        # Bit stuffing\n        stuffed = self._bit_stuff(frame_body)\n\n        # Flags\n        return bytes([FLAG]) + stuffed + bytes([FLAG])\n\n    @staticmethod\n    def _bit_stuff(data: bytes) -> bytes:\n        \"\"\"Apply AX.25 bit stuffing: insert 0 after five consecutive 1s.\"\"\"\n        result = bytearray()\n        ones_count = 0\n        current_byte = 0\n        bit_pos = 0\n\n        for byte in data:\n            for i in range(8):\n                bit = (byte >> i) & 1\n                current_byte |= bit << bit_pos\n                bit_pos += 1\n\n                if bit == 1:\n                    ones_count += 1\n                    if ones_count == 5:\n                        # Insert stuffed 0\n                        if bit_pos == 8:\n                            result.append(current_byte)\n                            current_byte = 0\n                            bit_pos = 0\n                        ones_count = 0\n                else:\n                    ones_count = 0\n\n                if bit_pos == 8:\n                    result.append(current_byte)\n                    current_byte = 0\n                    bit_pos = 0\n\n        # Flush remaining bits\n        if bit_pos > 0:\n            result.append(current_byte)\n\n        return bytes(result)\n\n    @classmethod\n    def _bit_destuff(cls, data: bytes) -> bytes:\n        \"\"\"Remove AX.25 bit stuffing: remove 0 after five consecutive 1s.\"\"\"\n        result = bytearray()\n        ones_count = 0\n        current_byte = 0\n        bit_pos = 0\n\n        for byte in data:\n            for i in range(8):\n                bit = (byte >> i) & 1\n                current_byte |= bit << bit_pos\n                bit_pos += 1\n\n                if ones_count == 5:\n                    if bit == 0:\n                        ones_count = 0\n                    else:\n                        raise BitStuffingError(\"Invalid stuffed sequence\")\n                    if bit_pos == 8:\n                        result.append(current_byte)\n                        current_byte = 0\n                        bit_pos = 0\n                    continue\n\n                if bit == 1:\n                    ones_count += 1\n                else:\n                    ones_count = 0\n\n                if bit_pos == 8:\n                    result.append(current_byte)\n                    current_byte = 0\n                    bit_pos = 0\n\n        # Flush\n        if bit_pos > 0:\n            result.append(current_byte)\n\n        return bytes(result)\n\n    @classmethod\n    def decode(cls, raw: bytes, config: AX25Config = DEFAULT_CONFIG_MOD8) -> \"AX25Frame\":\n        \"\"\"\n        Decode raw frame bytes (including flags).\n\n        Performs destuffing, FCS check, address/control parsing.\n        \"\"\"\n        if raw[0] != FLAG or raw[-1] != FLAG:\n            raise FrameError(\"Missing start/end flag\")\n\n        destuffed = cls._bit_destuff(raw[1:-1])\n\n        if len(destuffed) < 16:\n            raise FrameError(\"Frame too short after destuffing\")\n\n        # Parse addresses\n        offset = 0\n        dest, _ = AX25Address.decode(destuffed[offset:offset+7])\n        offset += 7\n        src, last = AX25Address.decode(destuffed[offset:offset+7])\n        offset += 7\n\n        digipeaters = []\n        while not last and offset + 7 <= len(destuffed):\n            digi, last = AX25Address.decode(destuffed[offset:offset+7])\n            digipeaters.append(digi)\n            offset += 7\n\n        # Control field\n        control = destuffed[offset]\n        offset += 1\n        if config.modulo == 128 and (control & 0x01 == 0):  # Extended I-frame\n            if offset >= len(destuffed):\n                raise FrameError(\"Truncated extended control field\")\n            control |= destuffed[offset] << 8\n            offset += 1\n\n        pid = None\n        if (control & 0x01 == 0) or (control & 0x03 == 0x03):\n            if offset >= len(destuffed):\n                raise FrameError(\"Truncated PID field\")\n            pid = destuffed[offset]\n            offset += 1\n\n        info = destuffed[offset:-2]\n        received_fcs = struct.unpack(\"<H\", destuffed[-2:])[0]\n\n        frame_without_fcs = destuffed[:-2]\n        if not verify_fcs(frame_without_fcs, received_fcs):\n            raise FCSError(\"Invalid FCS\")\n\n        return cls(\n            destination=dest,\n            source=src,\n            digipeaters=digipeaters,\n            control=control,\n            pid=pid,\n            info=info,\n            config=config,\n        )"
}
